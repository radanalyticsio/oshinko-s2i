#!/bin/bash

function set_app_file() {
    if [ "$#" -eq 1 ]; then
	APP_FILE_NAME=$1
	APP_FILE="-p APP_FILE=$1"
    else
	APP_FILE_NAME=
	APP_FILE=
    fi
}

function set_exit_flag() {
    if [ "$#" -eq 1 ]; then
	EXIT_FLAG="-p APP_EXIT=$1"
    else
	EXIT_FLAG=
    fi
}

function set_defaults() {
    TEST_MODE=false
    APPARGS=
    DEL_CLUSTER=false
    NAMED_CONFIG=clusterconfig
    DRIVER_CONFIG=
    SPARK_OPTIONS=
    GEN_CLUSTER_NAME=
    APP_NAME=
    RANDOM_NAME=false
    set_app_file
    set_exit_flag
}

function app_preamble() {
    if [ -z "$FIXED_APP_NAME" -o "$RANDOM_NAME" == true ]; then
        set +e
        SUFFIX=$(cat /dev/urandom | tr -dc 'a-z0-9' | fold -w 4 | head -n 1)
        set -e
        APP_NAME=app-$SUFFIX
    else
	APP_NAME=$FIXED_APP_NAME
    fi
    if [ "$GEN_CLUSTER_NAME" == "" ]; then
        GEN_CLUSTER_NAME=testenv
    fi
    MASTER_DC=$GEN_CLUSTER_NAME-m
    WORKER_DC=$GEN_CLUSTER_NAME-w
}

function set_fixed_app_name() {
    if [ "$#" -eq 1 ]; then
	FIXED_APP_NAME=$1
    else
	FIXED_APP_NAME=
    fi
}

function force_random_app_name() {
    RANDOM_NAME=true
}

function set_template() {
    TEMPLATE=$1
}

function set_git_uri() {
    if [ "$#" -eq 1 ]; then
	GIT_URI=$1
	SOURCE_INFO="-p GIT_URI=$1" 
    elif [ "$#" -eq 2 ]; then
	GIT_URI=$1
	SOURCE_INFO="-p GIT_URI=$1 -p GIT_REF=$2"
    else
	GIT_URI=
	SOURCE_INFO=
    fi
}

function set_image() {
    if [ "$#" -eq 1 ]; then
	SOURCE_INFO="-p IMAGE=$1"
    else
	SOURCE_INFO=
    fi
}

APP_MAIN_CLASS=
function set_app_main_class() {
    if [ "$#" -eq 1 ]; then
	APP_MAIN_CLASS="-p APP_MAIN_CLASS=$1"
    else
	APP_MAIN_CLASS=
    fi
}

function run_app() {
    app_preamble
    set +e
    oc new-app --file=$TEMPLATE $SOURCE_INFO -p APPLICATION_NAME=$APP_NAME -p APP_ARGS="$APPARGS" -p OSHINKO_DEL_CLUSTER=$DEL_CLUSTER -p OSHINKO_NAMED_CONFIG=$NAMED_CONFIG -p OSHINKO_SPARK_DRIVER_CONFIG=$DRIVER_CONFIG -p OSHINKO_CLUSTER_NAME=$GEN_CLUSTER_NAME -p SPARK_OPTIONS="$SPARK_OPTIONS" $APP_FILE $EXIT_FLAG $APP_MAIN_CLASS &> /dev/null
    set -e
    # Allow some tests to skip the wait for the running app, because they don't care
    if [ "$#" -eq 0 ]; then
        os::cmd::try_until_text 'oc logs dc/"$APP_NAME"' 'cluster' $((10*minute))
    fi
}


function run_app_without_optionals() {
    app_preamble
    set +e
    oc new-app --file=$TEMPLATE $SOURCE_INFO -p APPLICATION_NAME=$APP_NAME -p OSHINKO_CLUSTER_NAME=$GEN_CLUSTER_NAME $APP_MAIN_CLASS &> /dev/null
    set -e
    os::cmd::try_until_text 'oc logs dc/"$APP_NAME"' 'cluster'  $((10*minute))
}

function run_app_without_clustername() {
    app_preamble
    set +e
    oc new-app --file=$TEMPLATE $SOURCE_INFO -p APPLICATION_NAME=$APP_NAME $APP_MAIN_CLASS &> /dev/null
    set -e
    os::cmd::try_until_text 'oc logs dc/"$APP_NAME"' 'cluster'  $((10*minute))
}

function run_app_without_application_name() {
    app_preamble
    oc new-app --file=$TEMPLATE $SOURCE_INFO $APP_MAIN_CLASS &> /dev/null
}

function test_no_app_name {
    set_defaults
    os::cmd::expect_success 'oc delete dc -l app'
    os::cmd::try_until_text 'oc get pod -l app' 'No resources found'
    run_app_without_application_name
    os::cmd::try_until_not_text 'oc get pod -l app' 'No resources found' $((10*minute))
    DRIVER=$(oc get pod -l app --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_text 'oc logs "$DRIVER"' 'cluster'
    os::cmd::expect_success 'oc delete dc -l app'
}

function test_app_args {
    set_defaults
    APPARGS="doodleydoodley"
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "APP_ARGS=doodleydoodley$"'  $((5*minute))
    cleanup_app

    run_app_without_optionals
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "APP_ARGS=$"'  $((5*minute))
    cleanup_app
}

function test_podinfo {
    set_defaults
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- ls /etc/podinfo/labels'
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep POD_NAME="$DRIVER"'  $((5*minute))
    cleanup_app
}

function test_del_cluster {
    set_defaults
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "OSHINKO_DEL_CLUSTER=false$"'  $((5*minute))
    cleanup_app

    DEL_CLUSTER=true
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "OSHINKO_DEL_CLUSTER=true$"'  $((5*minute))
    cleanup_app

    run_app_without_optionals
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "OSHINKO_DEL_CLUSTER=true$"'  $((5*minute))
    cleanup_app
}

function test_cluster_name {
    set_defaults
    DEL_CLUSTER=true
    GEN_CLUSTER_NAME=jerry
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "OSHINKO_CLUSTER_NAME=jerry"'  $((5*minute))
    cleanup_app

    run_app_without_clustername
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "OSHINKO_CLUSTER_NAME=$"'  $((5*minute))
    cleanup_app
}

function test_no_source_or_image {
    set_defaults
    app_preamble
    os::cmd::expect_failure 'oc new-app --file="$TEMPLATE"'
}

function test_named_config {
    set_defaults
    NAMED_CONFIG=myconfig
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "OSHINKO_NAMED_CONFIG=myconfig$"' $((5*minute))
    cleanup_app

    run_app_without_optionals
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "OSHINKO_NAMED_CONFIG=$"' $((5*minute))
    cleanup_app
}

function test_app_file {
    # Look in the default app for the app_file value unset
    set_defaults
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep APP_FILE=$' $((10*minute))
    cleanup_app

    # Because the dc is bundled with a buildconfig, this will cause a new build. Force a different
    # app name so that the build doesn't conflict and we can keep the default one around.
    force_random_app_name
    set_app_file $1
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep APP_FILE="$APP_FILE_NAME"$' $((10*minute))
    cleanup_app
    oc delete buildconfig $APP_NAME &> /dev/null
    oc delete is $APP_NAME &> /dev/null
}

function test_git_ref {
    local old_source=$SOURCE_INFO
    local commit=$2 # commit value has to be named for os::cmd to do the substitution
    set_defaults

    # We want a new build to reference the git_ref but we don't want to delete the old build, so
    # force a new app name
    force_random_app_name
    set_git_uri $1 $commit
    run_app skipwait
    SOURCE_INFO=$old_source
    os::cmd::try_until_success 'oc logs "$APP_NAME"-1-build | grep -e "Commit:[[:space:]]" | grep "$commit"'
    cleanup_app
    os::cmd::expect_success 'oc delete buildconfig "$APP_NAME"'
    os::cmd::expect_success 'oc delete is "$APP_NAME"'
}

function test_driver_config {
    set_defaults
    DRIVER_CONFIG=myconfig
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "OSHINKO_SPARK_DRIVER_CONFIG=myconfig$"'  $((5*minute))
    cleanup_app

    run_app_without_optionals
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "OSHINKO_SPARK_DRIVER_CONFIG=$"'  $((5*minute))
    cleanup_app
}

function test_spark_options {
    set_defaults
    SPARK_OPTIONS="--conf somevalue=1"
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "SPARK_OPTIONS=--conf somevalue=1"'  $((5*minute))
    cleanup_app

    run_app_without_optionals
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "SPARK_OPTIONS=$"'  $((5*minute))
    cleanup_app
}

function test_exit {
    set_defaults
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "APP_EXIT=false"'  $((10*minute))
    cleanup_app

    set_exit_flag true
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "APP_EXIT=true"'  $((10*minute))
    cleanup_app

    set_exit_flag false
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "APP_EXIT=false"'  $((10*minute))
    cleanup_app
}

function test_fixed_exit {
    set_defaults
    run_app
    DRIVER=$(oc get pod -l deploymentconfig=$APP_NAME --template='{{index .items 0 "metadata" "name"}}')
    os::cmd::try_until_success 'oc exec "$DRIVER" -- env | grep "APP_EXIT=true"'  $((10*minute))
    cleanup_app
}
